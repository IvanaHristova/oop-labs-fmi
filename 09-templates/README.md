# Шаблони. Статични членове на клас

[Отиди към задачи](#задачи)

## Шаблони
Дефиниране на шаблон на функция:
```cpp
template <typename T>
void print(T el)
{
    std::cout << el << "\n";
}
```

Дефиниране на шаблон на клас:
```cpp
template <typename T>
class Box
{
public:
    Box(T el) : el(el) {}
    void print();
private:
    T el;
};

template <typename T>
void Box<T>::print()
{
    std::cout << el << "\n";
}
```

После можем да ги използваме за всякакви типове:
```cpp
int main()
{
    // function
    print(10);
    print("ab");

    // class
    Box<int> int_box(1);
    int_box.print();
}
```

:warning: **Само дефинирането на шаблон не създава конкретна функция или конкретен клас, a "план" за създаване на такива.**

Компилаторът търси за **инстанции** на шаблонната функция/клас,
конкретизирани към някой тип, и за намерените такива генерира съответна
функция/клас, замествайки обобщения тип с конкретния.

При примера по-горе, генерирани са следните:
- функция `void print(int el);`
- функция `void print(const char* el);`
- клас (името е примерно) `IntBox` с член-данна от тип `int` и подходяща `print` функция.

:question: Какво ще стане, ако извикаме функцията `print` върху тип, за който не е дефиниран оператора `<<` с поток?

**Забележка:** Използването на `typename` (или `class`, еквивалентно) значи, че параметърът `T` може да е от всеки тип. Може да имаме и параметри, които очакват конкретен тип:
```cpp
template <typename T, int N>
class FiniteBox
{
    T elements[N];
};
```

### **Решаване на проблема с имплементациите на шаблонни класове**
Нека имаме същия клас `Box`, деклариран в `box.hpp`, а член функцията `Box<T>::print()` да бъде имплементирана в `box.cpp`.

Kогато в `main.cpp` се опитваме да използваме класа:
```cpp
#include <iostream>
#include "box.hpp"

int main()
{
    Box<int> int_box(1);
    int_box.print();
}
```
получаваме следната грешка:
``undefined reference to `Box<int>::print()'``.

**Защо**: Тъй като `box.cpp` се компилира независимо от други `cpp` файлове, като `main.cpp`, то `box.cpp` не вижда никакви инстанции на `Box<int>`, съответно не е генерирал подходящ клас с подходяща функция `print()`.

**Решения**
1. Ръчно да инстанцираме `Box` с нужните ни типове. В случая,
   в `box.cpp` добавяме следния ред:
```cpp
template class Box<int>;
```
2. Да разпишем имплементациите в `box.hpp`, т.е. да пишем всичко в `box.hpp`.

## Статични членове на клас
Статичните член данни не принадлежат към обект на класа, а към целия клас.

Поради тези причини:
- статичните член функции могат да се викат без да съществува нито един обект от класа;
- статичните член данни имат само едно копие

Декларираме член данна/функция като статична, използвайки думата `static` в началото
на декларацията ѝ.

:question: Към какви член данни имат достъп статичните член функции?

## Задачи
**Зад. 1.**
Да се напише функция с името `min`, която приема масив от
обобщен тип елементи и намира най-малкия от тях.

:question: Какъв оператор трябва да бъде дефиниран върху типа елементи при извикване на функцията?

**Зад. 2.**
В локдаун, системите за доставка на храна набират популярност.
Група студенти от ФМИ вече имат свой ресторант и са решили да направят система за него.

Ресторантът е скромен и предлага следните ястия:
- шопска салата;
- ориз със зеленчуци;
- пилешко.

Реализирайте ястията с `enum class`.

Създайте клас `Order`, който отговаря на една поръчка от ресторанта. Всяка поръчка се характеризира с:
- идентификационен номер – цяло число, започващо от 0;
- ястието, което е поръчано;
- грамаж на поръчаното;
- адрес за доставка - низ до 255 символа.

Всяка поръчка трябва да стигне навреме, затова би било добра идея да се държат в опашка.
Но тъй като студентите може да се нуждаят от опашка в други
проекти, изискването е тя да работи с елементи от всякакъв тип.

Създайте подходящ клас `Queue`, реализиращ преоразмеряваща се **кръгова опашка**. Тя трябва да поддържа следните публични методи:
- `bool is_empty() const;` – връща дали опашката е празна;
- `void enqueue(T el);` – вкарва елемент в опашката;
- `T dequeue();` – връща следващия елемент от опашката и го премахва от нея;
- `T& peek();` – само връща следващия елемент от опашката.

Създайте и клас `FMIRestaurant` със следните публични методи:
- `void place_order(const Order& order);` – добавя нова поръчка;
- `const Queue<Order>& get_order_queue() const;` – връща константа референция към опашката от поръчки;
- `Order send_next_order();` – премахва следващата поръчка от опашката и връща нейно копие.
